
  class ASHRAE9012004_Prototype < ASHRAE9012004
  attr_reader :instvarbuilding_type
  def initialize
    super()
  end
end

  # This class represents a prototypical ASHRAE9012004 FullServiceRestaurant.
  class ASHRAE9012004FullServiceRestaurant < ASHRAE9012004
  @@building_type = "FullServiceRestaurant"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004FullServiceRestaurant, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(FullServiceRestaurant) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 Hospital.
  class ASHRAE9012004Hospital < ASHRAE9012004
  @@building_type = "Hospital"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004Hospital, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Hospital) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 HighriseApartment.
  class ASHRAE9012004HighriseApartment < ASHRAE9012004
  @@building_type = "HighriseApartment"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004HighriseApartment, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(HighriseApartment) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 LargeHotel.
  class ASHRAE9012004LargeHotel < ASHRAE9012004
  @@building_type = "LargeHotel"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004LargeHotel, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeHotel) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 LargeOffice.
  class ASHRAE9012004LargeOffice < ASHRAE9012004
  @@building_type = "LargeOffice"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004LargeOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 MediumOffice.
  class ASHRAE9012004MediumOffice < ASHRAE9012004
  @@building_type = "MediumOffice"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004MediumOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MediumOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 MidriseApartment.
  class ASHRAE9012004MidriseApartment < ASHRAE9012004
  @@building_type = "MidriseApartment"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004MidriseApartment, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MidriseApartment) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 Outpatient.
  class ASHRAE9012004Outpatient < ASHRAE9012004
  @@building_type = "Outpatient"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004Outpatient, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Outpatient) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 PrimarySchool.
  class ASHRAE9012004PrimarySchool < ASHRAE9012004
  @@building_type = "PrimarySchool"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004PrimarySchool, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(PrimarySchool) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 QuickServiceRestaurant.
  class ASHRAE9012004QuickServiceRestaurant < ASHRAE9012004
  @@building_type = "QuickServiceRestaurant"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004QuickServiceRestaurant, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(QuickServiceRestaurant) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 RetailStandalone.
  class ASHRAE9012004RetailStandalone < ASHRAE9012004
  @@building_type = "RetailStandalone"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004RetailStandalone, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(RetailStandalone) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 SecondarySchool.
  class ASHRAE9012004SecondarySchool < ASHRAE9012004
  @@building_type = "SecondarySchool"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004SecondarySchool, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SecondarySchool) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 SmallHotel.
  class ASHRAE9012004SmallHotel < ASHRAE9012004
  @@building_type = "SmallHotel"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004SmallHotel, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallHotel) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 SmallOffice.
  class ASHRAE9012004SmallOffice < ASHRAE9012004
  @@building_type = "SmallOffice"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004SmallOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 RetailStripmall.
  class ASHRAE9012004RetailStripmall < ASHRAE9012004
  @@building_type = "RetailStripmall"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004RetailStripmall, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(RetailStripmall) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 Warehouse.
  class ASHRAE9012004Warehouse < ASHRAE9012004
  @@building_type = "Warehouse"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004Warehouse, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Warehouse) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 SuperMarket.
  class ASHRAE9012004SuperMarket < ASHRAE9012004
  @@building_type = "SuperMarket"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004SuperMarket, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SuperMarket) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 SmallDataCenterLowITE.
  class ASHRAE9012004SmallDataCenterLowITE < ASHRAE9012004
  @@building_type = "SmallDataCenterLowITE"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004SmallDataCenterLowITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallDataCenterLowITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 SmallDataCenterHighITE.
  class ASHRAE9012004SmallDataCenterHighITE < ASHRAE9012004
  @@building_type = "SmallDataCenterHighITE"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004SmallDataCenterHighITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallDataCenterHighITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 LargeDataCenterLowITE.
  class ASHRAE9012004LargeDataCenterLowITE < ASHRAE9012004
  @@building_type = "LargeDataCenterLowITE"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004LargeDataCenterLowITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeDataCenterLowITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 LargeDataCenterHighITE.
  class ASHRAE9012004LargeDataCenterHighITE < ASHRAE9012004
  @@building_type = "LargeDataCenterHighITE"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004LargeDataCenterHighITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeDataCenterHighITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 SmallOfficeDetailed.
  class ASHRAE9012004SmallOfficeDetailed < ASHRAE9012004
  @@building_type = "SmallOfficeDetailed"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004SmallOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 MediumOfficeDetailed.
  class ASHRAE9012004MediumOfficeDetailed < ASHRAE9012004
  @@building_type = "MediumOfficeDetailed"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004MediumOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MediumOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 LargeOfficeDetailed.
  class ASHRAE9012004LargeOfficeDetailed < ASHRAE9012004
  @@building_type = "LargeOfficeDetailed"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004LargeOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 Laboratory.
  class ASHRAE9012004Laboratory < ASHRAE9012004
  @@building_type = "Laboratory"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004Laboratory, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Laboratory) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 College.
  class ASHRAE9012004College < ASHRAE9012004
  @@building_type = "College"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004College, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(College) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 CourtHouse.
  class ASHRAE9012004CourtHouse < ASHRAE9012004
  @@building_type = "CourtHouse"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004CourtHouse, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(CourtHouse) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 TallBuilding.
  class ASHRAE9012004TallBuilding < ASHRAE9012004
  @@building_type = "TallBuilding"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004TallBuilding, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(TallBuilding) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012004 SuperTallBuilding.
  class ASHRAE9012004SuperTallBuilding < ASHRAE9012004
  @@building_type = "SuperTallBuilding"
  register_standard ("90.1-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012004SuperTallBuilding, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SuperTallBuilding) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  class ASHRAE9012007_Prototype < ASHRAE9012007
  attr_reader :instvarbuilding_type
  def initialize
    super()
  end
end

  # This class represents a prototypical ASHRAE9012007 FullServiceRestaurant.
  class ASHRAE9012007FullServiceRestaurant < ASHRAE9012007
  @@building_type = "FullServiceRestaurant"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007FullServiceRestaurant, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(FullServiceRestaurant) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 Hospital.
  class ASHRAE9012007Hospital < ASHRAE9012007
  @@building_type = "Hospital"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007Hospital, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Hospital) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 HighriseApartment.
  class ASHRAE9012007HighriseApartment < ASHRAE9012007
  @@building_type = "HighriseApartment"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007HighriseApartment, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(HighriseApartment) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 LargeHotel.
  class ASHRAE9012007LargeHotel < ASHRAE9012007
  @@building_type = "LargeHotel"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007LargeHotel, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeHotel) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 LargeOffice.
  class ASHRAE9012007LargeOffice < ASHRAE9012007
  @@building_type = "LargeOffice"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007LargeOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 MediumOffice.
  class ASHRAE9012007MediumOffice < ASHRAE9012007
  @@building_type = "MediumOffice"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007MediumOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MediumOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 MidriseApartment.
  class ASHRAE9012007MidriseApartment < ASHRAE9012007
  @@building_type = "MidriseApartment"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007MidriseApartment, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MidriseApartment) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 Outpatient.
  class ASHRAE9012007Outpatient < ASHRAE9012007
  @@building_type = "Outpatient"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007Outpatient, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Outpatient) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 PrimarySchool.
  class ASHRAE9012007PrimarySchool < ASHRAE9012007
  @@building_type = "PrimarySchool"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007PrimarySchool, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(PrimarySchool) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 QuickServiceRestaurant.
  class ASHRAE9012007QuickServiceRestaurant < ASHRAE9012007
  @@building_type = "QuickServiceRestaurant"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007QuickServiceRestaurant, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(QuickServiceRestaurant) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 RetailStandalone.
  class ASHRAE9012007RetailStandalone < ASHRAE9012007
  @@building_type = "RetailStandalone"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007RetailStandalone, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(RetailStandalone) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 SecondarySchool.
  class ASHRAE9012007SecondarySchool < ASHRAE9012007
  @@building_type = "SecondarySchool"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007SecondarySchool, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SecondarySchool) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 SmallHotel.
  class ASHRAE9012007SmallHotel < ASHRAE9012007
  @@building_type = "SmallHotel"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007SmallHotel, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallHotel) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 SmallOffice.
  class ASHRAE9012007SmallOffice < ASHRAE9012007
  @@building_type = "SmallOffice"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007SmallOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 RetailStripmall.
  class ASHRAE9012007RetailStripmall < ASHRAE9012007
  @@building_type = "RetailStripmall"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007RetailStripmall, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(RetailStripmall) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 Warehouse.
  class ASHRAE9012007Warehouse < ASHRAE9012007
  @@building_type = "Warehouse"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007Warehouse, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Warehouse) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 SuperMarket.
  class ASHRAE9012007SuperMarket < ASHRAE9012007
  @@building_type = "SuperMarket"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007SuperMarket, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SuperMarket) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 SmallDataCenterLowITE.
  class ASHRAE9012007SmallDataCenterLowITE < ASHRAE9012007
  @@building_type = "SmallDataCenterLowITE"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007SmallDataCenterLowITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallDataCenterLowITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 SmallDataCenterHighITE.
  class ASHRAE9012007SmallDataCenterHighITE < ASHRAE9012007
  @@building_type = "SmallDataCenterHighITE"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007SmallDataCenterHighITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallDataCenterHighITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 LargeDataCenterLowITE.
  class ASHRAE9012007LargeDataCenterLowITE < ASHRAE9012007
  @@building_type = "LargeDataCenterLowITE"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007LargeDataCenterLowITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeDataCenterLowITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 LargeDataCenterHighITE.
  class ASHRAE9012007LargeDataCenterHighITE < ASHRAE9012007
  @@building_type = "LargeDataCenterHighITE"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007LargeDataCenterHighITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeDataCenterHighITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 SmallOfficeDetailed.
  class ASHRAE9012007SmallOfficeDetailed < ASHRAE9012007
  @@building_type = "SmallOfficeDetailed"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007SmallOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 MediumOfficeDetailed.
  class ASHRAE9012007MediumOfficeDetailed < ASHRAE9012007
  @@building_type = "MediumOfficeDetailed"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007MediumOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MediumOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 LargeOfficeDetailed.
  class ASHRAE9012007LargeOfficeDetailed < ASHRAE9012007
  @@building_type = "LargeOfficeDetailed"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007LargeOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 Laboratory.
  class ASHRAE9012007Laboratory < ASHRAE9012007
  @@building_type = "Laboratory"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007Laboratory, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Laboratory) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 College.
  class ASHRAE9012007College < ASHRAE9012007
  @@building_type = "College"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007College, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(College) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 CourtHouse.
  class ASHRAE9012007CourtHouse < ASHRAE9012007
  @@building_type = "CourtHouse"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007CourtHouse, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(CourtHouse) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 TallBuilding.
  class ASHRAE9012007TallBuilding < ASHRAE9012007
  @@building_type = "TallBuilding"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007TallBuilding, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(TallBuilding) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012007 SuperTallBuilding.
  class ASHRAE9012007SuperTallBuilding < ASHRAE9012007
  @@building_type = "SuperTallBuilding"
  register_standard ("90.1-2007_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012007SuperTallBuilding, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SuperTallBuilding) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  class ASHRAE9012010_Prototype < ASHRAE9012010
  attr_reader :instvarbuilding_type
  def initialize
    super()
  end
end

  # This class represents a prototypical ASHRAE9012010 FullServiceRestaurant.
  class ASHRAE9012010FullServiceRestaurant < ASHRAE9012010
  @@building_type = "FullServiceRestaurant"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010FullServiceRestaurant, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(FullServiceRestaurant) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 Hospital.
  class ASHRAE9012010Hospital < ASHRAE9012010
  @@building_type = "Hospital"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010Hospital, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Hospital) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 HighriseApartment.
  class ASHRAE9012010HighriseApartment < ASHRAE9012010
  @@building_type = "HighriseApartment"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010HighriseApartment, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(HighriseApartment) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 LargeHotel.
  class ASHRAE9012010LargeHotel < ASHRAE9012010
  @@building_type = "LargeHotel"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010LargeHotel, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeHotel) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 LargeOffice.
  class ASHRAE9012010LargeOffice < ASHRAE9012010
  @@building_type = "LargeOffice"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010LargeOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 MediumOffice.
  class ASHRAE9012010MediumOffice < ASHRAE9012010
  @@building_type = "MediumOffice"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010MediumOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MediumOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 MidriseApartment.
  class ASHRAE9012010MidriseApartment < ASHRAE9012010
  @@building_type = "MidriseApartment"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010MidriseApartment, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MidriseApartment) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 Outpatient.
  class ASHRAE9012010Outpatient < ASHRAE9012010
  @@building_type = "Outpatient"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010Outpatient, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Outpatient) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 PrimarySchool.
  class ASHRAE9012010PrimarySchool < ASHRAE9012010
  @@building_type = "PrimarySchool"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010PrimarySchool, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(PrimarySchool) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 QuickServiceRestaurant.
  class ASHRAE9012010QuickServiceRestaurant < ASHRAE9012010
  @@building_type = "QuickServiceRestaurant"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010QuickServiceRestaurant, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(QuickServiceRestaurant) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 RetailStandalone.
  class ASHRAE9012010RetailStandalone < ASHRAE9012010
  @@building_type = "RetailStandalone"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010RetailStandalone, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(RetailStandalone) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 SecondarySchool.
  class ASHRAE9012010SecondarySchool < ASHRAE9012010
  @@building_type = "SecondarySchool"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010SecondarySchool, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SecondarySchool) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 SmallHotel.
  class ASHRAE9012010SmallHotel < ASHRAE9012010
  @@building_type = "SmallHotel"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010SmallHotel, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallHotel) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 SmallOffice.
  class ASHRAE9012010SmallOffice < ASHRAE9012010
  @@building_type = "SmallOffice"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010SmallOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 RetailStripmall.
  class ASHRAE9012010RetailStripmall < ASHRAE9012010
  @@building_type = "RetailStripmall"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010RetailStripmall, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(RetailStripmall) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 Warehouse.
  class ASHRAE9012010Warehouse < ASHRAE9012010
  @@building_type = "Warehouse"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010Warehouse, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Warehouse) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 SuperMarket.
  class ASHRAE9012010SuperMarket < ASHRAE9012010
  @@building_type = "SuperMarket"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010SuperMarket, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SuperMarket) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 SmallDataCenterLowITE.
  class ASHRAE9012010SmallDataCenterLowITE < ASHRAE9012010
  @@building_type = "SmallDataCenterLowITE"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010SmallDataCenterLowITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallDataCenterLowITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 SmallDataCenterHighITE.
  class ASHRAE9012010SmallDataCenterHighITE < ASHRAE9012010
  @@building_type = "SmallDataCenterHighITE"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010SmallDataCenterHighITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallDataCenterHighITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 LargeDataCenterLowITE.
  class ASHRAE9012010LargeDataCenterLowITE < ASHRAE9012010
  @@building_type = "LargeDataCenterLowITE"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010LargeDataCenterLowITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeDataCenterLowITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 LargeDataCenterHighITE.
  class ASHRAE9012010LargeDataCenterHighITE < ASHRAE9012010
  @@building_type = "LargeDataCenterHighITE"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010LargeDataCenterHighITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeDataCenterHighITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 SmallOfficeDetailed.
  class ASHRAE9012010SmallOfficeDetailed < ASHRAE9012010
  @@building_type = "SmallOfficeDetailed"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010SmallOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 MediumOfficeDetailed.
  class ASHRAE9012010MediumOfficeDetailed < ASHRAE9012010
  @@building_type = "MediumOfficeDetailed"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010MediumOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MediumOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 LargeOfficeDetailed.
  class ASHRAE9012010LargeOfficeDetailed < ASHRAE9012010
  @@building_type = "LargeOfficeDetailed"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010LargeOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 Laboratory.
  class ASHRAE9012010Laboratory < ASHRAE9012010
  @@building_type = "Laboratory"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010Laboratory, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Laboratory) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 College.
  class ASHRAE9012010College < ASHRAE9012010
  @@building_type = "College"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010College, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(College) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 CourtHouse.
  class ASHRAE9012010CourtHouse < ASHRAE9012010
  @@building_type = "CourtHouse"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010CourtHouse, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(CourtHouse) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 TallBuilding.
  class ASHRAE9012010TallBuilding < ASHRAE9012010
  @@building_type = "TallBuilding"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010TallBuilding, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(TallBuilding) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012010 SuperTallBuilding.
  class ASHRAE9012010SuperTallBuilding < ASHRAE9012010
  @@building_type = "SuperTallBuilding"
  register_standard ("90.1-2010_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012010SuperTallBuilding, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SuperTallBuilding) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  class ASHRAE9012013_Prototype < ASHRAE9012013
  attr_reader :instvarbuilding_type
  def initialize
    super()
  end
end

  # This class represents a prototypical ASHRAE9012013 FullServiceRestaurant.
  class ASHRAE9012013FullServiceRestaurant < ASHRAE9012013
  @@building_type = "FullServiceRestaurant"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013FullServiceRestaurant, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(FullServiceRestaurant) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 Hospital.
  class ASHRAE9012013Hospital < ASHRAE9012013
  @@building_type = "Hospital"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013Hospital, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Hospital) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 HighriseApartment.
  class ASHRAE9012013HighriseApartment < ASHRAE9012013
  @@building_type = "HighriseApartment"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013HighriseApartment, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(HighriseApartment) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 LargeHotel.
  class ASHRAE9012013LargeHotel < ASHRAE9012013
  @@building_type = "LargeHotel"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013LargeHotel, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeHotel) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 LargeOffice.
  class ASHRAE9012013LargeOffice < ASHRAE9012013
  @@building_type = "LargeOffice"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013LargeOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 MediumOffice.
  class ASHRAE9012013MediumOffice < ASHRAE9012013
  @@building_type = "MediumOffice"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013MediumOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MediumOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 MidriseApartment.
  class ASHRAE9012013MidriseApartment < ASHRAE9012013
  @@building_type = "MidriseApartment"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013MidriseApartment, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MidriseApartment) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 Outpatient.
  class ASHRAE9012013Outpatient < ASHRAE9012013
  @@building_type = "Outpatient"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013Outpatient, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Outpatient) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 PrimarySchool.
  class ASHRAE9012013PrimarySchool < ASHRAE9012013
  @@building_type = "PrimarySchool"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013PrimarySchool, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(PrimarySchool) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 QuickServiceRestaurant.
  class ASHRAE9012013QuickServiceRestaurant < ASHRAE9012013
  @@building_type = "QuickServiceRestaurant"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013QuickServiceRestaurant, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(QuickServiceRestaurant) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 RetailStandalone.
  class ASHRAE9012013RetailStandalone < ASHRAE9012013
  @@building_type = "RetailStandalone"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013RetailStandalone, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(RetailStandalone) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 SecondarySchool.
  class ASHRAE9012013SecondarySchool < ASHRAE9012013
  @@building_type = "SecondarySchool"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013SecondarySchool, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SecondarySchool) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 SmallHotel.
  class ASHRAE9012013SmallHotel < ASHRAE9012013
  @@building_type = "SmallHotel"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013SmallHotel, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallHotel) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 SmallOffice.
  class ASHRAE9012013SmallOffice < ASHRAE9012013
  @@building_type = "SmallOffice"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013SmallOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 RetailStripmall.
  class ASHRAE9012013RetailStripmall < ASHRAE9012013
  @@building_type = "RetailStripmall"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013RetailStripmall, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(RetailStripmall) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 Warehouse.
  class ASHRAE9012013Warehouse < ASHRAE9012013
  @@building_type = "Warehouse"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013Warehouse, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Warehouse) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 SuperMarket.
  class ASHRAE9012013SuperMarket < ASHRAE9012013
  @@building_type = "SuperMarket"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013SuperMarket, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SuperMarket) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 SmallDataCenterLowITE.
  class ASHRAE9012013SmallDataCenterLowITE < ASHRAE9012013
  @@building_type = "SmallDataCenterLowITE"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013SmallDataCenterLowITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallDataCenterLowITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 SmallDataCenterHighITE.
  class ASHRAE9012013SmallDataCenterHighITE < ASHRAE9012013
  @@building_type = "SmallDataCenterHighITE"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013SmallDataCenterHighITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallDataCenterHighITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 LargeDataCenterLowITE.
  class ASHRAE9012013LargeDataCenterLowITE < ASHRAE9012013
  @@building_type = "LargeDataCenterLowITE"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013LargeDataCenterLowITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeDataCenterLowITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 LargeDataCenterHighITE.
  class ASHRAE9012013LargeDataCenterHighITE < ASHRAE9012013
  @@building_type = "LargeDataCenterHighITE"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013LargeDataCenterHighITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeDataCenterHighITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 SmallOfficeDetailed.
  class ASHRAE9012013SmallOfficeDetailed < ASHRAE9012013
  @@building_type = "SmallOfficeDetailed"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013SmallOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 MediumOfficeDetailed.
  class ASHRAE9012013MediumOfficeDetailed < ASHRAE9012013
  @@building_type = "MediumOfficeDetailed"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013MediumOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MediumOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 LargeOfficeDetailed.
  class ASHRAE9012013LargeOfficeDetailed < ASHRAE9012013
  @@building_type = "LargeOfficeDetailed"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013LargeOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 Laboratory.
  class ASHRAE9012013Laboratory < ASHRAE9012013
  @@building_type = "Laboratory"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013Laboratory, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Laboratory) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 College.
  class ASHRAE9012013College < ASHRAE9012013
  @@building_type = "College"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013College, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(College) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 CourtHouse.
  class ASHRAE9012013CourtHouse < ASHRAE9012013
  @@building_type = "CourtHouse"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013CourtHouse, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(CourtHouse) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 TallBuilding.
  class ASHRAE9012013TallBuilding < ASHRAE9012013
  @@building_type = "TallBuilding"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013TallBuilding, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(TallBuilding) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012013 SuperTallBuilding.
  class ASHRAE9012013SuperTallBuilding < ASHRAE9012013
  @@building_type = "SuperTallBuilding"
  register_standard ("90.1-2013_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012013SuperTallBuilding, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SuperTallBuilding) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  class ASHRAE9012016_Prototype < ASHRAE9012016
  attr_reader :instvarbuilding_type
  def initialize
    super()
  end
end

  # This class represents a prototypical ASHRAE9012016 FullServiceRestaurant.
  class ASHRAE9012016FullServiceRestaurant < ASHRAE9012016
  @@building_type = "FullServiceRestaurant"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016FullServiceRestaurant, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(FullServiceRestaurant) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 Hospital.
  class ASHRAE9012016Hospital < ASHRAE9012016
  @@building_type = "Hospital"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016Hospital, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Hospital) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 HighriseApartment.
  class ASHRAE9012016HighriseApartment < ASHRAE9012016
  @@building_type = "HighriseApartment"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016HighriseApartment, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(HighriseApartment) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 LargeHotel.
  class ASHRAE9012016LargeHotel < ASHRAE9012016
  @@building_type = "LargeHotel"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016LargeHotel, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeHotel) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 LargeOffice.
  class ASHRAE9012016LargeOffice < ASHRAE9012016
  @@building_type = "LargeOffice"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016LargeOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 MediumOffice.
  class ASHRAE9012016MediumOffice < ASHRAE9012016
  @@building_type = "MediumOffice"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016MediumOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MediumOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 MidriseApartment.
  class ASHRAE9012016MidriseApartment < ASHRAE9012016
  @@building_type = "MidriseApartment"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016MidriseApartment, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MidriseApartment) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 Outpatient.
  class ASHRAE9012016Outpatient < ASHRAE9012016
  @@building_type = "Outpatient"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016Outpatient, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Outpatient) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 PrimarySchool.
  class ASHRAE9012016PrimarySchool < ASHRAE9012016
  @@building_type = "PrimarySchool"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016PrimarySchool, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(PrimarySchool) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 QuickServiceRestaurant.
  class ASHRAE9012016QuickServiceRestaurant < ASHRAE9012016
  @@building_type = "QuickServiceRestaurant"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016QuickServiceRestaurant, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(QuickServiceRestaurant) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 RetailStandalone.
  class ASHRAE9012016RetailStandalone < ASHRAE9012016
  @@building_type = "RetailStandalone"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016RetailStandalone, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(RetailStandalone) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 SecondarySchool.
  class ASHRAE9012016SecondarySchool < ASHRAE9012016
  @@building_type = "SecondarySchool"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016SecondarySchool, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SecondarySchool) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 SmallHotel.
  class ASHRAE9012016SmallHotel < ASHRAE9012016
  @@building_type = "SmallHotel"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016SmallHotel, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallHotel) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 SmallOffice.
  class ASHRAE9012016SmallOffice < ASHRAE9012016
  @@building_type = "SmallOffice"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016SmallOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 RetailStripmall.
  class ASHRAE9012016RetailStripmall < ASHRAE9012016
  @@building_type = "RetailStripmall"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016RetailStripmall, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(RetailStripmall) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 Warehouse.
  class ASHRAE9012016Warehouse < ASHRAE9012016
  @@building_type = "Warehouse"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016Warehouse, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Warehouse) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 SuperMarket.
  class ASHRAE9012016SuperMarket < ASHRAE9012016
  @@building_type = "SuperMarket"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016SuperMarket, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SuperMarket) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 SmallDataCenterLowITE.
  class ASHRAE9012016SmallDataCenterLowITE < ASHRAE9012016
  @@building_type = "SmallDataCenterLowITE"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016SmallDataCenterLowITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallDataCenterLowITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 SmallDataCenterHighITE.
  class ASHRAE9012016SmallDataCenterHighITE < ASHRAE9012016
  @@building_type = "SmallDataCenterHighITE"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016SmallDataCenterHighITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallDataCenterHighITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 LargeDataCenterLowITE.
  class ASHRAE9012016LargeDataCenterLowITE < ASHRAE9012016
  @@building_type = "LargeDataCenterLowITE"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016LargeDataCenterLowITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeDataCenterLowITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 LargeDataCenterHighITE.
  class ASHRAE9012016LargeDataCenterHighITE < ASHRAE9012016
  @@building_type = "LargeDataCenterHighITE"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016LargeDataCenterHighITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeDataCenterHighITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 SmallOfficeDetailed.
  class ASHRAE9012016SmallOfficeDetailed < ASHRAE9012016
  @@building_type = "SmallOfficeDetailed"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016SmallOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 MediumOfficeDetailed.
  class ASHRAE9012016MediumOfficeDetailed < ASHRAE9012016
  @@building_type = "MediumOfficeDetailed"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016MediumOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MediumOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 LargeOfficeDetailed.
  class ASHRAE9012016LargeOfficeDetailed < ASHRAE9012016
  @@building_type = "LargeOfficeDetailed"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016LargeOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 Laboratory.
  class ASHRAE9012016Laboratory < ASHRAE9012016
  @@building_type = "Laboratory"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016Laboratory, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Laboratory) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 College.
  class ASHRAE9012016College < ASHRAE9012016
  @@building_type = "College"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016College, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(College) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 CourtHouse.
  class ASHRAE9012016CourtHouse < ASHRAE9012016
  @@building_type = "CourtHouse"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016CourtHouse, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(CourtHouse) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 TallBuilding.
  class ASHRAE9012016TallBuilding < ASHRAE9012016
  @@building_type = "TallBuilding"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016TallBuilding, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(TallBuilding) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012016 SuperTallBuilding.
  class ASHRAE9012016SuperTallBuilding < ASHRAE9012016
  @@building_type = "SuperTallBuilding"
  register_standard ("90.1-2016_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012016SuperTallBuilding, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SuperTallBuilding) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  class ASHRAE9012019_Prototype < ASHRAE9012019
  attr_reader :instvarbuilding_type
  def initialize
    super()
  end
end

  # This class represents a prototypical ASHRAE9012019 FullServiceRestaurant.
  class ASHRAE9012019FullServiceRestaurant < ASHRAE9012019
  @@building_type = "FullServiceRestaurant"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019FullServiceRestaurant, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(FullServiceRestaurant) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 Hospital.
  class ASHRAE9012019Hospital < ASHRAE9012019
  @@building_type = "Hospital"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019Hospital, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Hospital) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 HighriseApartment.
  class ASHRAE9012019HighriseApartment < ASHRAE9012019
  @@building_type = "HighriseApartment"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019HighriseApartment, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(HighriseApartment) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 LargeHotel.
  class ASHRAE9012019LargeHotel < ASHRAE9012019
  @@building_type = "LargeHotel"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019LargeHotel, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeHotel) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 LargeOffice.
  class ASHRAE9012019LargeOffice < ASHRAE9012019
  @@building_type = "LargeOffice"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019LargeOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 MediumOffice.
  class ASHRAE9012019MediumOffice < ASHRAE9012019
  @@building_type = "MediumOffice"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019MediumOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MediumOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 MidriseApartment.
  class ASHRAE9012019MidriseApartment < ASHRAE9012019
  @@building_type = "MidriseApartment"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019MidriseApartment, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MidriseApartment) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 Outpatient.
  class ASHRAE9012019Outpatient < ASHRAE9012019
  @@building_type = "Outpatient"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019Outpatient, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Outpatient) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 PrimarySchool.
  class ASHRAE9012019PrimarySchool < ASHRAE9012019
  @@building_type = "PrimarySchool"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019PrimarySchool, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(PrimarySchool) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 QuickServiceRestaurant.
  class ASHRAE9012019QuickServiceRestaurant < ASHRAE9012019
  @@building_type = "QuickServiceRestaurant"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019QuickServiceRestaurant, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(QuickServiceRestaurant) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 RetailStandalone.
  class ASHRAE9012019RetailStandalone < ASHRAE9012019
  @@building_type = "RetailStandalone"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019RetailStandalone, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(RetailStandalone) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 SecondarySchool.
  class ASHRAE9012019SecondarySchool < ASHRAE9012019
  @@building_type = "SecondarySchool"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019SecondarySchool, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SecondarySchool) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 SmallHotel.
  class ASHRAE9012019SmallHotel < ASHRAE9012019
  @@building_type = "SmallHotel"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019SmallHotel, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallHotel) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 SmallOffice.
  class ASHRAE9012019SmallOffice < ASHRAE9012019
  @@building_type = "SmallOffice"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019SmallOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 RetailStripmall.
  class ASHRAE9012019RetailStripmall < ASHRAE9012019
  @@building_type = "RetailStripmall"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019RetailStripmall, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(RetailStripmall) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 Warehouse.
  class ASHRAE9012019Warehouse < ASHRAE9012019
  @@building_type = "Warehouse"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019Warehouse, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Warehouse) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 SuperMarket.
  class ASHRAE9012019SuperMarket < ASHRAE9012019
  @@building_type = "SuperMarket"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019SuperMarket, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SuperMarket) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 SmallDataCenterLowITE.
  class ASHRAE9012019SmallDataCenterLowITE < ASHRAE9012019
  @@building_type = "SmallDataCenterLowITE"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019SmallDataCenterLowITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallDataCenterLowITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 SmallDataCenterHighITE.
  class ASHRAE9012019SmallDataCenterHighITE < ASHRAE9012019
  @@building_type = "SmallDataCenterHighITE"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019SmallDataCenterHighITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallDataCenterHighITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 LargeDataCenterLowITE.
  class ASHRAE9012019LargeDataCenterLowITE < ASHRAE9012019
  @@building_type = "LargeDataCenterLowITE"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019LargeDataCenterLowITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeDataCenterLowITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 LargeDataCenterHighITE.
  class ASHRAE9012019LargeDataCenterHighITE < ASHRAE9012019
  @@building_type = "LargeDataCenterHighITE"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019LargeDataCenterHighITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeDataCenterHighITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 SmallOfficeDetailed.
  class ASHRAE9012019SmallOfficeDetailed < ASHRAE9012019
  @@building_type = "SmallOfficeDetailed"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019SmallOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 MediumOfficeDetailed.
  class ASHRAE9012019MediumOfficeDetailed < ASHRAE9012019
  @@building_type = "MediumOfficeDetailed"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019MediumOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MediumOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 LargeOfficeDetailed.
  class ASHRAE9012019LargeOfficeDetailed < ASHRAE9012019
  @@building_type = "LargeOfficeDetailed"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019LargeOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 Laboratory.
  class ASHRAE9012019Laboratory < ASHRAE9012019
  @@building_type = "Laboratory"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019Laboratory, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Laboratory) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 College.
  class ASHRAE9012019College < ASHRAE9012019
  @@building_type = "College"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019College, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(College) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 CourtHouse.
  class ASHRAE9012019CourtHouse < ASHRAE9012019
  @@building_type = "CourtHouse"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019CourtHouse, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(CourtHouse) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 TallBuilding.
  class ASHRAE9012019TallBuilding < ASHRAE9012019
  @@building_type = "TallBuilding"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019TallBuilding, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(TallBuilding) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical ASHRAE9012019 SuperTallBuilding.
  class ASHRAE9012019SuperTallBuilding < ASHRAE9012019
  @@building_type = "SuperTallBuilding"
  register_standard ("90.1-2019_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for ASHRAE9012019SuperTallBuilding, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SuperTallBuilding) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  class DOERef1980to2004_Prototype < DOERef1980to2004
  attr_reader :instvarbuilding_type
  def initialize
    super()
  end
end

  # This class represents a prototypical DOERef1980to2004 FullServiceRestaurant.
  class DOERef1980to2004FullServiceRestaurant < DOERef1980to2004
  @@building_type = "FullServiceRestaurant"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004FullServiceRestaurant, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(FullServiceRestaurant) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 Hospital.
  class DOERef1980to2004Hospital < DOERef1980to2004
  @@building_type = "Hospital"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004Hospital, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Hospital) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 HighriseApartment.
  class DOERef1980to2004HighriseApartment < DOERef1980to2004
  @@building_type = "HighriseApartment"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004HighriseApartment, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(HighriseApartment) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 LargeHotel.
  class DOERef1980to2004LargeHotel < DOERef1980to2004
  @@building_type = "LargeHotel"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004LargeHotel, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeHotel) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 LargeOffice.
  class DOERef1980to2004LargeOffice < DOERef1980to2004
  @@building_type = "LargeOffice"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004LargeOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 MediumOffice.
  class DOERef1980to2004MediumOffice < DOERef1980to2004
  @@building_type = "MediumOffice"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004MediumOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MediumOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 MidriseApartment.
  class DOERef1980to2004MidriseApartment < DOERef1980to2004
  @@building_type = "MidriseApartment"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004MidriseApartment, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MidriseApartment) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 Outpatient.
  class DOERef1980to2004Outpatient < DOERef1980to2004
  @@building_type = "Outpatient"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004Outpatient, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Outpatient) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 PrimarySchool.
  class DOERef1980to2004PrimarySchool < DOERef1980to2004
  @@building_type = "PrimarySchool"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004PrimarySchool, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(PrimarySchool) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 QuickServiceRestaurant.
  class DOERef1980to2004QuickServiceRestaurant < DOERef1980to2004
  @@building_type = "QuickServiceRestaurant"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004QuickServiceRestaurant, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(QuickServiceRestaurant) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 RetailStandalone.
  class DOERef1980to2004RetailStandalone < DOERef1980to2004
  @@building_type = "RetailStandalone"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004RetailStandalone, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(RetailStandalone) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 SecondarySchool.
  class DOERef1980to2004SecondarySchool < DOERef1980to2004
  @@building_type = "SecondarySchool"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004SecondarySchool, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SecondarySchool) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 SmallHotel.
  class DOERef1980to2004SmallHotel < DOERef1980to2004
  @@building_type = "SmallHotel"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004SmallHotel, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallHotel) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 SmallOffice.
  class DOERef1980to2004SmallOffice < DOERef1980to2004
  @@building_type = "SmallOffice"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004SmallOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 RetailStripmall.
  class DOERef1980to2004RetailStripmall < DOERef1980to2004
  @@building_type = "RetailStripmall"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004RetailStripmall, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(RetailStripmall) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 Warehouse.
  class DOERef1980to2004Warehouse < DOERef1980to2004
  @@building_type = "Warehouse"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004Warehouse, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Warehouse) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 SuperMarket.
  class DOERef1980to2004SuperMarket < DOERef1980to2004
  @@building_type = "SuperMarket"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004SuperMarket, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SuperMarket) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 SmallDataCenterLowITE.
  class DOERef1980to2004SmallDataCenterLowITE < DOERef1980to2004
  @@building_type = "SmallDataCenterLowITE"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004SmallDataCenterLowITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallDataCenterLowITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 SmallDataCenterHighITE.
  class DOERef1980to2004SmallDataCenterHighITE < DOERef1980to2004
  @@building_type = "SmallDataCenterHighITE"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004SmallDataCenterHighITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallDataCenterHighITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 LargeDataCenterLowITE.
  class DOERef1980to2004LargeDataCenterLowITE < DOERef1980to2004
  @@building_type = "LargeDataCenterLowITE"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004LargeDataCenterLowITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeDataCenterLowITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 LargeDataCenterHighITE.
  class DOERef1980to2004LargeDataCenterHighITE < DOERef1980to2004
  @@building_type = "LargeDataCenterHighITE"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004LargeDataCenterHighITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeDataCenterHighITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 SmallOfficeDetailed.
  class DOERef1980to2004SmallOfficeDetailed < DOERef1980to2004
  @@building_type = "SmallOfficeDetailed"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004SmallOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 MediumOfficeDetailed.
  class DOERef1980to2004MediumOfficeDetailed < DOERef1980to2004
  @@building_type = "MediumOfficeDetailed"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004MediumOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MediumOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 LargeOfficeDetailed.
  class DOERef1980to2004LargeOfficeDetailed < DOERef1980to2004
  @@building_type = "LargeOfficeDetailed"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004LargeOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 Laboratory.
  class DOERef1980to2004Laboratory < DOERef1980to2004
  @@building_type = "Laboratory"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004Laboratory, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Laboratory) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 College.
  class DOERef1980to2004College < DOERef1980to2004
  @@building_type = "College"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004College, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(College) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 CourtHouse.
  class DOERef1980to2004CourtHouse < DOERef1980to2004
  @@building_type = "CourtHouse"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004CourtHouse, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(CourtHouse) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 TallBuilding.
  class DOERef1980to2004TallBuilding < DOERef1980to2004
  @@building_type = "TallBuilding"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004TallBuilding, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(TallBuilding) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERef1980to2004 SuperTallBuilding.
  class DOERef1980to2004SuperTallBuilding < DOERef1980to2004
  @@building_type = "SuperTallBuilding"
  register_standard ("DOE Ref 1980-2004_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERef1980to2004SuperTallBuilding, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SuperTallBuilding) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  class DOERefPre1980_Prototype < DOERefPre1980
  attr_reader :instvarbuilding_type
  def initialize
    super()
  end
end

  # This class represents a prototypical DOERefPre1980 FullServiceRestaurant.
  class DOERefPre1980FullServiceRestaurant < DOERefPre1980
  @@building_type = "FullServiceRestaurant"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980FullServiceRestaurant, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(FullServiceRestaurant) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 Hospital.
  class DOERefPre1980Hospital < DOERefPre1980
  @@building_type = "Hospital"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980Hospital, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Hospital) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 HighriseApartment.
  class DOERefPre1980HighriseApartment < DOERefPre1980
  @@building_type = "HighriseApartment"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980HighriseApartment, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(HighriseApartment) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 LargeHotel.
  class DOERefPre1980LargeHotel < DOERefPre1980
  @@building_type = "LargeHotel"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980LargeHotel, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeHotel) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 LargeOffice.
  class DOERefPre1980LargeOffice < DOERefPre1980
  @@building_type = "LargeOffice"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980LargeOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 MediumOffice.
  class DOERefPre1980MediumOffice < DOERefPre1980
  @@building_type = "MediumOffice"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980MediumOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MediumOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 MidriseApartment.
  class DOERefPre1980MidriseApartment < DOERefPre1980
  @@building_type = "MidriseApartment"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980MidriseApartment, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MidriseApartment) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 Outpatient.
  class DOERefPre1980Outpatient < DOERefPre1980
  @@building_type = "Outpatient"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980Outpatient, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Outpatient) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 PrimarySchool.
  class DOERefPre1980PrimarySchool < DOERefPre1980
  @@building_type = "PrimarySchool"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980PrimarySchool, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(PrimarySchool) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 QuickServiceRestaurant.
  class DOERefPre1980QuickServiceRestaurant < DOERefPre1980
  @@building_type = "QuickServiceRestaurant"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980QuickServiceRestaurant, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(QuickServiceRestaurant) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 RetailStandalone.
  class DOERefPre1980RetailStandalone < DOERefPre1980
  @@building_type = "RetailStandalone"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980RetailStandalone, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(RetailStandalone) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 SecondarySchool.
  class DOERefPre1980SecondarySchool < DOERefPre1980
  @@building_type = "SecondarySchool"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980SecondarySchool, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SecondarySchool) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 SmallHotel.
  class DOERefPre1980SmallHotel < DOERefPre1980
  @@building_type = "SmallHotel"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980SmallHotel, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallHotel) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 SmallOffice.
  class DOERefPre1980SmallOffice < DOERefPre1980
  @@building_type = "SmallOffice"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980SmallOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 RetailStripmall.
  class DOERefPre1980RetailStripmall < DOERefPre1980
  @@building_type = "RetailStripmall"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980RetailStripmall, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(RetailStripmall) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 Warehouse.
  class DOERefPre1980Warehouse < DOERefPre1980
  @@building_type = "Warehouse"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980Warehouse, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Warehouse) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 SuperMarket.
  class DOERefPre1980SuperMarket < DOERefPre1980
  @@building_type = "SuperMarket"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980SuperMarket, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SuperMarket) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 SmallDataCenterLowITE.
  class DOERefPre1980SmallDataCenterLowITE < DOERefPre1980
  @@building_type = "SmallDataCenterLowITE"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980SmallDataCenterLowITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallDataCenterLowITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 SmallDataCenterHighITE.
  class DOERefPre1980SmallDataCenterHighITE < DOERefPre1980
  @@building_type = "SmallDataCenterHighITE"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980SmallDataCenterHighITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallDataCenterHighITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 LargeDataCenterLowITE.
  class DOERefPre1980LargeDataCenterLowITE < DOERefPre1980
  @@building_type = "LargeDataCenterLowITE"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980LargeDataCenterLowITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeDataCenterLowITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 LargeDataCenterHighITE.
  class DOERefPre1980LargeDataCenterHighITE < DOERefPre1980
  @@building_type = "LargeDataCenterHighITE"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980LargeDataCenterHighITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeDataCenterHighITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 SmallOfficeDetailed.
  class DOERefPre1980SmallOfficeDetailed < DOERefPre1980
  @@building_type = "SmallOfficeDetailed"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980SmallOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 MediumOfficeDetailed.
  class DOERefPre1980MediumOfficeDetailed < DOERefPre1980
  @@building_type = "MediumOfficeDetailed"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980MediumOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MediumOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 LargeOfficeDetailed.
  class DOERefPre1980LargeOfficeDetailed < DOERefPre1980
  @@building_type = "LargeOfficeDetailed"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980LargeOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 Laboratory.
  class DOERefPre1980Laboratory < DOERefPre1980
  @@building_type = "Laboratory"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980Laboratory, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Laboratory) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 College.
  class DOERefPre1980College < DOERefPre1980
  @@building_type = "College"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980College, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(College) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 CourtHouse.
  class DOERefPre1980CourtHouse < DOERefPre1980
  @@building_type = "CourtHouse"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980CourtHouse, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(CourtHouse) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 TallBuilding.
  class DOERefPre1980TallBuilding < DOERefPre1980
  @@building_type = "TallBuilding"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980TallBuilding, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(TallBuilding) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical DOERefPre1980 SuperTallBuilding.
  class DOERefPre1980SuperTallBuilding < DOERefPre1980
  @@building_type = "SuperTallBuilding"
  register_standard ("DOE Ref Pre-1980_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for DOERefPre1980SuperTallBuilding, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SuperTallBuilding) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  class NRELZNEReady2017_Prototype < NRELZNEReady2017
  attr_reader :instvarbuilding_type
  def initialize
    super()
  end
end

  # This class represents a prototypical NRELZNEReady2017 FullServiceRestaurant.
  class NRELZNEReady2017FullServiceRestaurant < NRELZNEReady2017
  @@building_type = "FullServiceRestaurant"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017FullServiceRestaurant, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(FullServiceRestaurant) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 Hospital.
  class NRELZNEReady2017Hospital < NRELZNEReady2017
  @@building_type = "Hospital"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017Hospital, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Hospital) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 HighriseApartment.
  class NRELZNEReady2017HighriseApartment < NRELZNEReady2017
  @@building_type = "HighriseApartment"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017HighriseApartment, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(HighriseApartment) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 LargeHotel.
  class NRELZNEReady2017LargeHotel < NRELZNEReady2017
  @@building_type = "LargeHotel"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017LargeHotel, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeHotel) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 LargeOffice.
  class NRELZNEReady2017LargeOffice < NRELZNEReady2017
  @@building_type = "LargeOffice"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017LargeOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 MediumOffice.
  class NRELZNEReady2017MediumOffice < NRELZNEReady2017
  @@building_type = "MediumOffice"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017MediumOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MediumOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 MidriseApartment.
  class NRELZNEReady2017MidriseApartment < NRELZNEReady2017
  @@building_type = "MidriseApartment"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017MidriseApartment, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MidriseApartment) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 Outpatient.
  class NRELZNEReady2017Outpatient < NRELZNEReady2017
  @@building_type = "Outpatient"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017Outpatient, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Outpatient) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 PrimarySchool.
  class NRELZNEReady2017PrimarySchool < NRELZNEReady2017
  @@building_type = "PrimarySchool"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017PrimarySchool, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(PrimarySchool) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 QuickServiceRestaurant.
  class NRELZNEReady2017QuickServiceRestaurant < NRELZNEReady2017
  @@building_type = "QuickServiceRestaurant"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017QuickServiceRestaurant, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(QuickServiceRestaurant) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 RetailStandalone.
  class NRELZNEReady2017RetailStandalone < NRELZNEReady2017
  @@building_type = "RetailStandalone"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017RetailStandalone, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(RetailStandalone) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 SecondarySchool.
  class NRELZNEReady2017SecondarySchool < NRELZNEReady2017
  @@building_type = "SecondarySchool"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017SecondarySchool, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SecondarySchool) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 SmallHotel.
  class NRELZNEReady2017SmallHotel < NRELZNEReady2017
  @@building_type = "SmallHotel"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017SmallHotel, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallHotel) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 SmallOffice.
  class NRELZNEReady2017SmallOffice < NRELZNEReady2017
  @@building_type = "SmallOffice"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017SmallOffice, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallOffice) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 RetailStripmall.
  class NRELZNEReady2017RetailStripmall < NRELZNEReady2017
  @@building_type = "RetailStripmall"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017RetailStripmall, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(RetailStripmall) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 Warehouse.
  class NRELZNEReady2017Warehouse < NRELZNEReady2017
  @@building_type = "Warehouse"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017Warehouse, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Warehouse) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 SuperMarket.
  class NRELZNEReady2017SuperMarket < NRELZNEReady2017
  @@building_type = "SuperMarket"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017SuperMarket, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SuperMarket) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 SmallDataCenterLowITE.
  class NRELZNEReady2017SmallDataCenterLowITE < NRELZNEReady2017
  @@building_type = "SmallDataCenterLowITE"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017SmallDataCenterLowITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallDataCenterLowITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 SmallDataCenterHighITE.
  class NRELZNEReady2017SmallDataCenterHighITE < NRELZNEReady2017
  @@building_type = "SmallDataCenterHighITE"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017SmallDataCenterHighITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallDataCenterHighITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 LargeDataCenterLowITE.
  class NRELZNEReady2017LargeDataCenterLowITE < NRELZNEReady2017
  @@building_type = "LargeDataCenterLowITE"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017LargeDataCenterLowITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeDataCenterLowITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 LargeDataCenterHighITE.
  class NRELZNEReady2017LargeDataCenterHighITE < NRELZNEReady2017
  @@building_type = "LargeDataCenterHighITE"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017LargeDataCenterHighITE, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeDataCenterHighITE) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 SmallOfficeDetailed.
  class NRELZNEReady2017SmallOfficeDetailed < NRELZNEReady2017
  @@building_type = "SmallOfficeDetailed"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017SmallOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SmallOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 MediumOfficeDetailed.
  class NRELZNEReady2017MediumOfficeDetailed < NRELZNEReady2017
  @@building_type = "MediumOfficeDetailed"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017MediumOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(MediumOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 LargeOfficeDetailed.
  class NRELZNEReady2017LargeOfficeDetailed < NRELZNEReady2017
  @@building_type = "LargeOfficeDetailed"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017LargeOfficeDetailed, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(LargeOfficeDetailed) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 Laboratory.
  class NRELZNEReady2017Laboratory < NRELZNEReady2017
  @@building_type = "Laboratory"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017Laboratory, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(Laboratory) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 College.
  class NRELZNEReady2017College < NRELZNEReady2017
  @@building_type = "College"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017College, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(College) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 CourtHouse.
  class NRELZNEReady2017CourtHouse < NRELZNEReady2017
  @@building_type = "CourtHouse"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017CourtHouse, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(CourtHouse) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 TallBuilding.
  class NRELZNEReady2017TallBuilding < NRELZNEReady2017
  @@building_type = "TallBuilding"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017TallBuilding, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(TallBuilding) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  # This class represents a prototypical NRELZNEReady2017 SuperTallBuilding.
  class NRELZNEReady2017SuperTallBuilding < NRELZNEReady2017
  @@building_type = "SuperTallBuilding"
  register_standard ("NREL ZNE Ready 2017_#{@@building_type}")
  attr_accessor :prototype_database
  attr_accessor :prototype_input
  attr_accessor :lookup_building_type
  attr_accessor :space_type_map
  attr_accessor :geometry_file
  attr_accessor :building_story_map
  attr_accessor :system_to_space_map
  def initialize
    super()
    @instvarbuilding_type = @@building_type
    @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs',search_criteria: {'template' => @template,'building_type' => @@building_type })
    if @prototype_input.nil?
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => @template,'building_type' => @@building_type }}, cannot create model.")
      raise("Could not find prototype inputs for NRELZNEReady2017SuperTallBuilding, cannot create model.")
      return false
    end
    @lookup_building_type = self.model_get_lookup_name(@@building_type)
    #ideally we should map the data required to a instance variable.
    @geometry_file = 'geometry/' + @prototype_input['geometry_osm']
    hvac_map_file =  'geometry/' + @prototype_input['hvac_json']
    @system_to_space_map = load_hvac_map(hvac_map_file)
    self.set_variables()
  end
  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
  def set_variables()
    # Will be overwritten in class reopen file.
    # add all building methods for now.
    self.extend(SuperTallBuilding) unless @template == 'NECB 2011'
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
  def define_space_type_map(building_type, climate_zone)
    return @space_type_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
  def define_hvac_system_map(building_type, climate_zone)
    return @system_to_space_map
  end
  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end
  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end
  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end
  # Get the name of the building type used in lookups
  #
  # @param building_type [String] the building type
  # @return [String] returns the lookup name as a string
  # @todo Unify the lookup names and eliminate this method
  def model_get_lookup_name(building_type)
    lookup_name = building_type
    case building_type
      when 'SmallOffice'
        lookup_name = 'Office'
      when 'MediumOffice'
        lookup_name = 'Office'
      when 'LargeOffice'
        lookup_name = 'Office'
      when 'SmallOfficeDetailed'
        lookup_name = 'Office'
      when 'MediumOfficeDetailed'
        lookup_name = 'Office'
	  when 'LargeOfficeDetailed'
        lookup_name = 'Office'
      when 'RetailStandalone'
        lookup_name = 'Retail'
      when 'RetailStripmall'
        lookup_name = 'StripMall'
      when 'Office'
        lookup_name = 'Office'
    end
    return lookup_name
  end

  # Makes changes to the daylighting sensors that are too
  # specific to be coded generically.
  #
  # @return [Bool] returns true if successful, false if not
  def model_custom_daylighting_tweaks(building_type, climate_zone, prototype_input, model)
    return true
  end
end

  class NECB2011_Prototype < NECB2011
  attr_reader :instvarbuilding_type
  def initialize
    super()
  end
end

  # This class represents a prototypical NECB2011 FullServiceRestaurant.
  class NECB2011FullServiceRestaurant < NECB2011
    BUILDING_TYPE = "FullServiceRestaurant"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "FullServiceRestaurant" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "FullServiceRestaurant" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 FullServiceRestaurant, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 Hospital.
  class NECB2011Hospital < NECB2011
    BUILDING_TYPE = "Hospital"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "Hospital" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "Hospital" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 Hospital, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 HighriseApartment.
  class NECB2011HighriseApartment < NECB2011
    BUILDING_TYPE = "HighriseApartment"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "HighriseApartment" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "HighriseApartment" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 HighriseApartment, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 LargeHotel.
  class NECB2011LargeHotel < NECB2011
    BUILDING_TYPE = "LargeHotel"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "LargeHotel" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "LargeHotel" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 LargeHotel, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 LargeOffice.
  class NECB2011LargeOffice < NECB2011
    BUILDING_TYPE = "LargeOffice"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "LargeOffice" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "LargeOffice" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 LargeOffice, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 MediumOffice.
  class NECB2011MediumOffice < NECB2011
    BUILDING_TYPE = "MediumOffice"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "MediumOffice" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "MediumOffice" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 MediumOffice, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 MidriseApartment.
  class NECB2011MidriseApartment < NECB2011
    BUILDING_TYPE = "MidriseApartment"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "MidriseApartment" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "MidriseApartment" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 MidriseApartment, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 Outpatient.
  class NECB2011Outpatient < NECB2011
    BUILDING_TYPE = "Outpatient"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "Outpatient" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "Outpatient" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 Outpatient, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 PrimarySchool.
  class NECB2011PrimarySchool < NECB2011
    BUILDING_TYPE = "PrimarySchool"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "PrimarySchool" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "PrimarySchool" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 PrimarySchool, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 QuickServiceRestaurant.
  class NECB2011QuickServiceRestaurant < NECB2011
    BUILDING_TYPE = "QuickServiceRestaurant"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "QuickServiceRestaurant" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "QuickServiceRestaurant" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 QuickServiceRestaurant, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 RetailStandalone.
  class NECB2011RetailStandalone < NECB2011
    BUILDING_TYPE = "RetailStandalone"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "RetailStandalone" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "RetailStandalone" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 RetailStandalone, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 SecondarySchool.
  class NECB2011SecondarySchool < NECB2011
    BUILDING_TYPE = "SecondarySchool"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "SecondarySchool" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "SecondarySchool" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 SecondarySchool, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 SmallHotel.
  class NECB2011SmallHotel < NECB2011
    BUILDING_TYPE = "SmallHotel"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "SmallHotel" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "SmallHotel" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 SmallHotel, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 SmallOffice.
  class NECB2011SmallOffice < NECB2011
    BUILDING_TYPE = "SmallOffice"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "SmallOffice" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "SmallOffice" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 SmallOffice, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 RetailStripmall.
  class NECB2011RetailStripmall < NECB2011
    BUILDING_TYPE = "RetailStripmall"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "RetailStripmall" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "RetailStripmall" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 RetailStripmall, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 Warehouse.
  class NECB2011Warehouse < NECB2011
    BUILDING_TYPE = "Warehouse"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "Warehouse" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "Warehouse" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 Warehouse, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 SuperMarket.
  class NECB2011SuperMarket < NECB2011
    BUILDING_TYPE = "SuperMarket"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "SuperMarket" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "SuperMarket" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 SuperMarket, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 SmallDataCenterLowITE.
  class NECB2011SmallDataCenterLowITE < NECB2011
    BUILDING_TYPE = "SmallDataCenterLowITE"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "SmallDataCenterLowITE" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "SmallDataCenterLowITE" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 SmallDataCenterLowITE, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 SmallDataCenterHighITE.
  class NECB2011SmallDataCenterHighITE < NECB2011
    BUILDING_TYPE = "SmallDataCenterHighITE"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "SmallDataCenterHighITE" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "SmallDataCenterHighITE" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 SmallDataCenterHighITE, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 LargeDataCenterLowITE.
  class NECB2011LargeDataCenterLowITE < NECB2011
    BUILDING_TYPE = "LargeDataCenterLowITE"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "LargeDataCenterLowITE" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "LargeDataCenterLowITE" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 LargeDataCenterLowITE, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 LargeDataCenterHighITE.
  class NECB2011LargeDataCenterHighITE < NECB2011
    BUILDING_TYPE = "LargeDataCenterHighITE"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "LargeDataCenterHighITE" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "LargeDataCenterHighITE" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 LargeDataCenterHighITE, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 SmallOfficeDetailed.
  class NECB2011SmallOfficeDetailed < NECB2011
    BUILDING_TYPE = "SmallOfficeDetailed"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "SmallOfficeDetailed" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "SmallOfficeDetailed" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 SmallOfficeDetailed, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 MediumOfficeDetailed.
  class NECB2011MediumOfficeDetailed < NECB2011
    BUILDING_TYPE = "MediumOfficeDetailed"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "MediumOfficeDetailed" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "MediumOfficeDetailed" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 MediumOfficeDetailed, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 LargeOfficeDetailed.
  class NECB2011LargeOfficeDetailed < NECB2011
    BUILDING_TYPE = "LargeOfficeDetailed"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "LargeOfficeDetailed" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "LargeOfficeDetailed" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 LargeOfficeDetailed, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 Laboratory.
  class NECB2011Laboratory < NECB2011
    BUILDING_TYPE = "Laboratory"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "Laboratory" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "Laboratory" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 Laboratory, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 College.
  class NECB2011College < NECB2011
    BUILDING_TYPE = "College"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "College" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "College" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 College, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 CourtHouse.
  class NECB2011CourtHouse < NECB2011
    BUILDING_TYPE = "CourtHouse"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "CourtHouse" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "CourtHouse" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 CourtHouse, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 TallBuilding.
  class NECB2011TallBuilding < NECB2011
    BUILDING_TYPE = "TallBuilding"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "TallBuilding" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "TallBuilding" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 TallBuilding, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2011 SuperTallBuilding.
  class NECB2011SuperTallBuilding < NECB2011
    BUILDING_TYPE = "SuperTallBuilding"
    TEMPLATE =  "NECB2011"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2011",'building_type' => "SuperTallBuilding" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2011",'building_type' => "SuperTallBuilding" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2011 SuperTallBuilding, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  class NECB2015_Prototype < NECB2015
  attr_reader :instvarbuilding_type
  def initialize
    super()
  end
end

  # This class represents a prototypical NECB2015 FullServiceRestaurant.
  class NECB2015FullServiceRestaurant < NECB2015
    BUILDING_TYPE = "FullServiceRestaurant"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "FullServiceRestaurant" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "FullServiceRestaurant" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 FullServiceRestaurant, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 Hospital.
  class NECB2015Hospital < NECB2015
    BUILDING_TYPE = "Hospital"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "Hospital" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "Hospital" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 Hospital, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 HighriseApartment.
  class NECB2015HighriseApartment < NECB2015
    BUILDING_TYPE = "HighriseApartment"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "HighriseApartment" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "HighriseApartment" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 HighriseApartment, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 LargeHotel.
  class NECB2015LargeHotel < NECB2015
    BUILDING_TYPE = "LargeHotel"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "LargeHotel" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "LargeHotel" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 LargeHotel, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 LargeOffice.
  class NECB2015LargeOffice < NECB2015
    BUILDING_TYPE = "LargeOffice"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "LargeOffice" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "LargeOffice" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 LargeOffice, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 MediumOffice.
  class NECB2015MediumOffice < NECB2015
    BUILDING_TYPE = "MediumOffice"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "MediumOffice" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "MediumOffice" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 MediumOffice, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 MidriseApartment.
  class NECB2015MidriseApartment < NECB2015
    BUILDING_TYPE = "MidriseApartment"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "MidriseApartment" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "MidriseApartment" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 MidriseApartment, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 Outpatient.
  class NECB2015Outpatient < NECB2015
    BUILDING_TYPE = "Outpatient"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "Outpatient" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "Outpatient" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 Outpatient, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 PrimarySchool.
  class NECB2015PrimarySchool < NECB2015
    BUILDING_TYPE = "PrimarySchool"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "PrimarySchool" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "PrimarySchool" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 PrimarySchool, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 QuickServiceRestaurant.
  class NECB2015QuickServiceRestaurant < NECB2015
    BUILDING_TYPE = "QuickServiceRestaurant"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "QuickServiceRestaurant" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "QuickServiceRestaurant" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 QuickServiceRestaurant, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 RetailStandalone.
  class NECB2015RetailStandalone < NECB2015
    BUILDING_TYPE = "RetailStandalone"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "RetailStandalone" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "RetailStandalone" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 RetailStandalone, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 SecondarySchool.
  class NECB2015SecondarySchool < NECB2015
    BUILDING_TYPE = "SecondarySchool"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "SecondarySchool" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "SecondarySchool" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 SecondarySchool, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 SmallHotel.
  class NECB2015SmallHotel < NECB2015
    BUILDING_TYPE = "SmallHotel"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "SmallHotel" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "SmallHotel" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 SmallHotel, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 SmallOffice.
  class NECB2015SmallOffice < NECB2015
    BUILDING_TYPE = "SmallOffice"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "SmallOffice" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "SmallOffice" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 SmallOffice, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 RetailStripmall.
  class NECB2015RetailStripmall < NECB2015
    BUILDING_TYPE = "RetailStripmall"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "RetailStripmall" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "RetailStripmall" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 RetailStripmall, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 Warehouse.
  class NECB2015Warehouse < NECB2015
    BUILDING_TYPE = "Warehouse"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "Warehouse" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "Warehouse" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 Warehouse, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 SuperMarket.
  class NECB2015SuperMarket < NECB2015
    BUILDING_TYPE = "SuperMarket"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "SuperMarket" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "SuperMarket" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 SuperMarket, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 SmallDataCenterLowITE.
  class NECB2015SmallDataCenterLowITE < NECB2015
    BUILDING_TYPE = "SmallDataCenterLowITE"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "SmallDataCenterLowITE" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "SmallDataCenterLowITE" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 SmallDataCenterLowITE, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 SmallDataCenterHighITE.
  class NECB2015SmallDataCenterHighITE < NECB2015
    BUILDING_TYPE = "SmallDataCenterHighITE"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "SmallDataCenterHighITE" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "SmallDataCenterHighITE" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 SmallDataCenterHighITE, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 LargeDataCenterLowITE.
  class NECB2015LargeDataCenterLowITE < NECB2015
    BUILDING_TYPE = "LargeDataCenterLowITE"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "LargeDataCenterLowITE" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "LargeDataCenterLowITE" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 LargeDataCenterLowITE, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 LargeDataCenterHighITE.
  class NECB2015LargeDataCenterHighITE < NECB2015
    BUILDING_TYPE = "LargeDataCenterHighITE"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "LargeDataCenterHighITE" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "LargeDataCenterHighITE" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 LargeDataCenterHighITE, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 SmallOfficeDetailed.
  class NECB2015SmallOfficeDetailed < NECB2015
    BUILDING_TYPE = "SmallOfficeDetailed"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "SmallOfficeDetailed" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "SmallOfficeDetailed" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 SmallOfficeDetailed, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 MediumOfficeDetailed.
  class NECB2015MediumOfficeDetailed < NECB2015
    BUILDING_TYPE = "MediumOfficeDetailed"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "MediumOfficeDetailed" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "MediumOfficeDetailed" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 MediumOfficeDetailed, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 LargeOfficeDetailed.
  class NECB2015LargeOfficeDetailed < NECB2015
    BUILDING_TYPE = "LargeOfficeDetailed"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "LargeOfficeDetailed" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "LargeOfficeDetailed" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 LargeOfficeDetailed, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 Laboratory.
  class NECB2015Laboratory < NECB2015
    BUILDING_TYPE = "Laboratory"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "Laboratory" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "Laboratory" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 Laboratory, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 College.
  class NECB2015College < NECB2015
    BUILDING_TYPE = "College"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "College" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "College" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 College, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 CourtHouse.
  class NECB2015CourtHouse < NECB2015
    BUILDING_TYPE = "CourtHouse"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "CourtHouse" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "CourtHouse" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 CourtHouse, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 TallBuilding.
  class NECB2015TallBuilding < NECB2015
    BUILDING_TYPE = "TallBuilding"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "TallBuilding" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "TallBuilding" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 TallBuilding, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2015 SuperTallBuilding.
  class NECB2015SuperTallBuilding < NECB2015
    BUILDING_TYPE = "SuperTallBuilding"
    TEMPLATE =  "NECB2015"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2015",'building_type' => "SuperTallBuilding" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2015",'building_type' => "SuperTallBuilding" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2015 SuperTallBuilding, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  class NECB2017_Prototype < NECB2017
  attr_reader :instvarbuilding_type
  def initialize
    super()
  end
end

  # This class represents a prototypical NECB2017 FullServiceRestaurant.
  class NECB2017FullServiceRestaurant < NECB2017
    BUILDING_TYPE = "FullServiceRestaurant"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "FullServiceRestaurant" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "FullServiceRestaurant" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 FullServiceRestaurant, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 Hospital.
  class NECB2017Hospital < NECB2017
    BUILDING_TYPE = "Hospital"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "Hospital" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "Hospital" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 Hospital, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 HighriseApartment.
  class NECB2017HighriseApartment < NECB2017
    BUILDING_TYPE = "HighriseApartment"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "HighriseApartment" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "HighriseApartment" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 HighriseApartment, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 LargeHotel.
  class NECB2017LargeHotel < NECB2017
    BUILDING_TYPE = "LargeHotel"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "LargeHotel" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "LargeHotel" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 LargeHotel, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 LargeOffice.
  class NECB2017LargeOffice < NECB2017
    BUILDING_TYPE = "LargeOffice"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "LargeOffice" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "LargeOffice" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 LargeOffice, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 MediumOffice.
  class NECB2017MediumOffice < NECB2017
    BUILDING_TYPE = "MediumOffice"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "MediumOffice" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "MediumOffice" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 MediumOffice, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 MidriseApartment.
  class NECB2017MidriseApartment < NECB2017
    BUILDING_TYPE = "MidriseApartment"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "MidriseApartment" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "MidriseApartment" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 MidriseApartment, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 Outpatient.
  class NECB2017Outpatient < NECB2017
    BUILDING_TYPE = "Outpatient"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "Outpatient" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "Outpatient" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 Outpatient, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 PrimarySchool.
  class NECB2017PrimarySchool < NECB2017
    BUILDING_TYPE = "PrimarySchool"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "PrimarySchool" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "PrimarySchool" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 PrimarySchool, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 QuickServiceRestaurant.
  class NECB2017QuickServiceRestaurant < NECB2017
    BUILDING_TYPE = "QuickServiceRestaurant"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "QuickServiceRestaurant" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "QuickServiceRestaurant" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 QuickServiceRestaurant, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 RetailStandalone.
  class NECB2017RetailStandalone < NECB2017
    BUILDING_TYPE = "RetailStandalone"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "RetailStandalone" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "RetailStandalone" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 RetailStandalone, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 SecondarySchool.
  class NECB2017SecondarySchool < NECB2017
    BUILDING_TYPE = "SecondarySchool"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "SecondarySchool" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "SecondarySchool" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 SecondarySchool, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 SmallHotel.
  class NECB2017SmallHotel < NECB2017
    BUILDING_TYPE = "SmallHotel"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "SmallHotel" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "SmallHotel" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 SmallHotel, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 SmallOffice.
  class NECB2017SmallOffice < NECB2017
    BUILDING_TYPE = "SmallOffice"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "SmallOffice" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "SmallOffice" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 SmallOffice, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 RetailStripmall.
  class NECB2017RetailStripmall < NECB2017
    BUILDING_TYPE = "RetailStripmall"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "RetailStripmall" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "RetailStripmall" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 RetailStripmall, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 Warehouse.
  class NECB2017Warehouse < NECB2017
    BUILDING_TYPE = "Warehouse"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "Warehouse" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "Warehouse" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 Warehouse, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 SuperMarket.
  class NECB2017SuperMarket < NECB2017
    BUILDING_TYPE = "SuperMarket"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "SuperMarket" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "SuperMarket" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 SuperMarket, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 SmallDataCenterLowITE.
  class NECB2017SmallDataCenterLowITE < NECB2017
    BUILDING_TYPE = "SmallDataCenterLowITE"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "SmallDataCenterLowITE" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "SmallDataCenterLowITE" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 SmallDataCenterLowITE, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 SmallDataCenterHighITE.
  class NECB2017SmallDataCenterHighITE < NECB2017
    BUILDING_TYPE = "SmallDataCenterHighITE"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "SmallDataCenterHighITE" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "SmallDataCenterHighITE" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 SmallDataCenterHighITE, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 LargeDataCenterLowITE.
  class NECB2017LargeDataCenterLowITE < NECB2017
    BUILDING_TYPE = "LargeDataCenterLowITE"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "LargeDataCenterLowITE" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "LargeDataCenterLowITE" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 LargeDataCenterLowITE, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 LargeDataCenterHighITE.
  class NECB2017LargeDataCenterHighITE < NECB2017
    BUILDING_TYPE = "LargeDataCenterHighITE"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "LargeDataCenterHighITE" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "LargeDataCenterHighITE" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 LargeDataCenterHighITE, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 SmallOfficeDetailed.
  class NECB2017SmallOfficeDetailed < NECB2017
    BUILDING_TYPE = "SmallOfficeDetailed"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "SmallOfficeDetailed" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "SmallOfficeDetailed" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 SmallOfficeDetailed, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 MediumOfficeDetailed.
  class NECB2017MediumOfficeDetailed < NECB2017
    BUILDING_TYPE = "MediumOfficeDetailed"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "MediumOfficeDetailed" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "MediumOfficeDetailed" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 MediumOfficeDetailed, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 LargeOfficeDetailed.
  class NECB2017LargeOfficeDetailed < NECB2017
    BUILDING_TYPE = "LargeOfficeDetailed"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "LargeOfficeDetailed" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "LargeOfficeDetailed" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 LargeOfficeDetailed, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 Laboratory.
  class NECB2017Laboratory < NECB2017
    BUILDING_TYPE = "Laboratory"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "Laboratory" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "Laboratory" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 Laboratory, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 College.
  class NECB2017College < NECB2017
    BUILDING_TYPE = "College"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "College" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "College" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 College, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 CourtHouse.
  class NECB2017CourtHouse < NECB2017
    BUILDING_TYPE = "CourtHouse"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "CourtHouse" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "CourtHouse" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 CourtHouse, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 TallBuilding.
  class NECB2017TallBuilding < NECB2017
    BUILDING_TYPE = "TallBuilding"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "TallBuilding" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "TallBuilding" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 TallBuilding, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end

  # This class represents a prototypical NECB2017 SuperTallBuilding.
  class NECB2017SuperTallBuilding < NECB2017
    BUILDING_TYPE = "SuperTallBuilding"
    TEMPLATE =  "NECB2017"
    register_standard ("#{TEMPLATE}_#{BUILDING_TYPE}")
    attr_accessor :prototype_database
    attr_accessor :prototype_input
    attr_accessor :lookup_building_type
    attr_accessor :space_type_map
    attr_accessor :geometry_file
    attr_accessor :building_story_map
    attr_accessor :system_to_space_map

    def initialize
      super()
      @building_type = BUILDING_TYPE
      @template = TEMPLATE
      @instvarbuilding_type = @building_type
      @prototype_input = self.standards_lookup_table_first(table_name: 'prototype_inputs', search_criteria: {'template' => "NECB2017",'building_type' => "SuperTallBuilding" })
      if @prototype_input.nil?
        OpenStudio.logFree(OpenStudio::Error, 'openstudio.standards.Model', "Could not find prototype inputs for #{{'template' => "NECB2017",'building_type' => "SuperTallBuilding" }}, cannot create model.")
        #puts JSON.pretty_generate(standards_data['prototype_inputs'])
        raise("Could not find prototype inputs for NECB2017 SuperTallBuilding, cannot create model.")
        return false
      end
      @lookup_building_type = self.model_get_lookup_name(@building_type)
      #ideally we should map the data required to a instance variable.
      @geometry_file = 'geometry/' + self.class.name + '.osm'
      hvac_map_file =  'geometry/' + self.class.name + '.hvac_map.json'
      # @system_to_space_map = load_hvac_map(hvac_map_file) # No HVAC map json files for NECB
      self.set_variables()
    end

  # This method is used to extend the class with building-type-specific
  # methods, as defined in Prototype.SomeBuildingType.rb.  Each building type
  # has its own set of methods that change things which are not
  # common across all prototype buildings, even within a given Standard.
    def set_variables()
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the space types
  # available for this particular Standard.
    def define_space_type_map(building_type, climate_zone)
      return @space_type_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the HVAC system that will
  # be applied to those spaces.
    def define_hvac_system_map(building_type, climate_zone)
      return @system_to_space_map
    end

  # Returns the mapping between the names of the spaces
  # in the geometry .osm file and the building story
  # that they are located on.
  def define_building_story_map(building_type, climate_zone)
     return @building_story_map
  end

  # Does nothing unless implmented by the specific standard
  def model_modify_oa_controller(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_reset_or_room_vav_minimum_damper(prototype_input, model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_exhaust_fan_efficiency(model)
  end

  # Does nothing unless implmented by the specific standard
  def model_update_fan_efficiency(model)
  end

end
